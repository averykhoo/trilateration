% Trilateration using Non Linear Least Squares Model
% Extension from Linear Least Squares code attempted

% For NLSQ, use LSQ as initial guess.
% Aim of NLSQ is to reduce the error between actual distance and measured 
% distance (from anchor to tag) to the minimum. 

% Source: "Trilateration: The Mathematics behind a Local Positioning System"
% by Willy Hereman, Turgut Ozal University, Department of Computer
% Engineering, 21st June 2011

% Uses either one of the models (please comment out model not in use)
% 1. Dummy model check using known tag(target) coordinates with
% corresponding formulas 
% 2. Arbitrary inputs of distance measured between anchor and tag(target)

% Units for values are in metres

clc


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   initializing variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Set coordinates of 4 anchors; let Anchor 1 be reference point
A1 = [-100;     1;     0];
A2 = [  10;     2;  1000];
A3 = [1000; -1000;    11];
A4 = [1500;   500;   500];

% Set coordinate of tag, let extrapolated tag be x; this is meant as 
% reference coordinates for debugging
Tag = [-1808.232; 152.23123; 1012];

% Set distance from anchor to tag
% r1 is measured distance between reference anchor and Tag
% r(i), i = 1 to n is distance from anchor to tag
% General formula for distance from anchor to tag
r1 = sqrt((Tag(1,1) - A1(1,1)) ^ 2 ...
        + (Tag(2,1) - A1(2,1)) ^ 2 ...
        + (Tag(3,1) - A1(3,1)) ^ 2
        ) + 0.9;
r2 = sqrt((Tag(1,1) - A2(1,1)) ^ 2 ...
        + (Tag(2,1) - A2(2,1)) ^ 2 ...
        + (Tag(3,1) - A2(3,1)) ^ 2
        ) - 0.2;
r3 = sqrt((Tag(1,1) - A3(1,1)) ^ 2 ...
        + (Tag(2,1) - A3(2,1)) ^ 2 ...
        + (Tag(3,1) - A3(3,1)) ^ 2
        ) + 1.1;
r4 = sqrt((Tag(1,1) - A4(1,1)) ^ 2 ...
        + (Tag(2,1) - A4(2,1)) ^ 2 ...
        + (Tag(3,1) - A4(3,1)) ^ 2
        ) - 0.8;

% Input mesaured distance from anchor to tag here
% r1 = 7;
% r2 = 6;
% r3 = 8;
% r4 = 5;

% set learning rate alpha for NLSQ optimization
% lower values give more accurate results, higher values converge faster
% sane values are (probably) between 1.2 to 0.1
% algorithm default is 1.0
alpha = 0.7;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   LSQ to get initial estimate
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% d(i)(r) is distance between anchor and reference anchor; i = 1 to n, r is reference 
d21 = sqrt((A2(1,1) - A1(1,1)) ^ 2 ...
         + (A2(2,1) - A1(2,1)) ^ 2 ...
         + (A2(3,1) - A1(3,1)) ^ 2 ...
         );
d31 = sqrt((A3(1,1) - A1(1,1)) ^ 2 ...
         + (A3(2,1) - A1(2,1)) ^ 2 ...
         + (A3(3,1) - A1(3,1)) ^ 2 ...
         );
d41 = sqrt((A4(1,1) - A1(1,1)) ^ 2 ...
         + (A4(2,1) - A1(2,1)) ^ 2 ...
         + (A4(3,1) - A1(3,1)) ^ 2 ...
         );

% Set up Linear Least Squares model
b21 = 0.5*((r1)^2 - (r2)^2 + (d21)^2);
b31 = 0.5*((r1)^2 - (r3)^2 + (d31)^2);
b41 = 0.5*((r1)^2 - (r4)^2 + (d41)^2);

% Ax = b, assume A'A is non-singular and well-conditioned; A' is tranpose in MATLAB terms
A = [transpose(A2-A1); transpose(A3-A1); transpose(A4-A1)];
b = [b21; b31; b41];
x = inv(transpose(A) * A) * transpose(A) * b;

% Actual coordinates of tag by LSQ method. Let this set of coordinates be
% C1.
% Because x in this case is really [x-x(A0); y-y(A0); z-z(A0)], need to add
% back A0's coordinates to find actual tag coordinates from LSQ method
C1 = x + A1;

% Aim of NLSQ is to minimise Error function F = sum(ei^2), 
% ei = sqrt((x-xi)^2+(y-yi)^2+(z-zi)^2) - r(i), i = 1 to n
e1  = abs(sqrt((C1(1,1) - A1(1,1)) ^ 2 ...
             + (C1(2,1) - A1(2,1)) ^ 2 ...
             + (C1(3,1) - A1(3,1)) ^ 2 ...
             ) - r1);
e2  = abs(sqrt((C1(1,1) - A2(1,1)) ^ 2 ...
             + (C1(2,1) - A2(2,1)) ^ 2 ...
             + (C1(3,1) - A2(3,1)) ^ 2 ...
             ) - r2);
e3  = abs(sqrt((C1(1,1) - A3(1,1)) ^ 2 ...
             + (C1(2,1) - A3(2,1)) ^ 2 ...
             + (C1(3,1) - A3(3,1)) ^ 2 ...
             ) - r3);
e4  = abs(sqrt((C1(1,1) - A4(1,1)) ^ 2 ...
             + (C1(2,1) - A4(2,1)) ^ 2 ...
             + (C1(3,1) - A4(3,1)) ^ 2 ...
             ) - r4);
% This shall be initial value of overall error
overall_error = e1 + e2 + e3 + e4;
lsq_error = overall_error;

% Get corrected actual coordinates. Let this be C.
C = C1; % Set LSQ result as initial guess


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   NLSQ starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% use Newton Ralphton method to reduce error to minimum
best_error = overall_error;
best_guess = C;
% impose cap on iterations run: max 1000 iterations before stop
iter_cap = 100;
for iter_count = 1:iter_cap
    % Let there be distance between anchor and tag d(i), i = 0 to n
    d1 = sqrt((C(1,1) - A1(1,1)) ^ 2 ...
            + (C(2,1) - A1(2,1)) ^ 2 ...
            + (C(3,1) - A1(3,1)) ^ 2 ...            
            );
    d2 = sqrt((C(1,1) - A2(1,1)) ^ 2 ...
            + (C(2,1) - A2(2,1)) ^ 2 ...
            + (C(3,1) - A2(3,1)) ^ 2 ...            
            );
    d3 = sqrt((C(1,1) - A3(1,1)) ^ 2 ...
            + (C(2,1) - A3(2,1)) ^ 2 ...
            + (C(3,1) - A3(3,1)) ^ 2 ...            
            );
    d4 = sqrt((C(1,1) - A4(1,1)) ^ 2 ...
            + (C(2,1) - A4(2,1)) ^ 2 ...
            + (C(3,1) - A4(3,1)) ^ 2 ...            
            );    
            
    % Let there be Jacobian of tag coordinates J(q).
    % Let there be variable JqE aka transpose of J(q)*e
    xe  = (C(1,1) - A1(1,1)) * (d1 - r1) / d1 ...
        + (C(1,1) - A2(1,1)) * (d2 - r2) / d2 ...
        + (C(1,1) - A3(1,1)) * (d3 - r3) / d3 ...
        + (C(1,1) - A4(1,1)) * (d4 - r4) / d4;
    ye  = (C(2,1) - A1(2,1)) * (d1 - r1) / d1 ...
        + (C(2,1) - A2(2,1)) * (d2 - r2) / d2 ...
        + (C(2,1) - A3(2,1)) * (d3 - r3) / d3 ...
        + (C(2,1) - A4(2,1)) * (d4 - r4) / d4;
    ze  = (C(3,1) - A1(3,1)) * (d1 - r1) / d1 ...
        + (C(3,1) - A2(3,1)) * (d2 - r2) / d2 ...
        + (C(3,1) - A3(3,1)) * (d3 - r3) / d3 ...
        + (C(3,1) - A4(3,1)) * (d4 - r4) / d4;
        
    JqE = [xe; ye; ze];

    % Let there be square matrix g = J(q)'*J(q)
    Jx  = (C(1,1) - A1(1,1)) ^ 2 / (d1 ^ 2) ...
        + (C(1,1) - A2(1,1)) ^ 2 / (d2 ^ 2) ...
        + (C(1,1) - A3(1,1)) ^ 2 / (d3 ^ 2) ...
        + (C(1,1) - A4(1,1)) ^ 2 / (d4 ^ 2);
    Jz  = (C(3,1) - A1(3,1)) ^ 2 / (d1 ^ 2) ...
        + (C(3,1) - A2(3,1)) ^ 2 / (d2 ^ 2) ...
        + (C(3,1) - A3(3,1)) ^ 2 / (d3 ^ 2) ...
        + (C(3,1) - A4(3,1)) ^ 2 / (d4 ^ 2);
    Jy  = (C(2,1) - A1(2,1)) ^ 2 / (d1 ^ 2) ...
        + (C(2,1) - A2(2,1)) ^ 2 / (d2 ^ 2) ...
        + (C(2,1) - A3(2,1)) ^ 2 / (d3 ^ 2) ...
        + (C(2,1) - A4(2,1)) ^ 2 / (d4 ^ 2);
    
    Jxy = (C(1,1) - A1(1,1)) * (C(2,1) - A1(2,1)) / (d1 ^ 2) ...
        + (C(1,1) - A2(1,1)) * (C(2,1) - A2(2,1)) / (d2 ^ 2) ...
        + (C(1,1) - A3(1,1)) * (C(2,1) - A3(2,1)) / (d3 ^ 2) ...
        + (C(1,1) - A4(1,1)) * (C(2,1) - A4(2,1)) / (d4 ^ 2);
    Jxz = (C(1,1) - A1(1,1)) * (C(3,1) - A1(3,1)) / (d1 ^ 2) ...
        + (C(1,1) - A2(1,1)) * (C(3,1) - A2(3,1)) / (d2 ^ 2) ...
        + (C(1,1) - A3(1,1)) * (C(3,1) - A3(3,1)) / (d3 ^ 2) ...
        + (C(1,1) - A4(1,1)) * (C(3,1) - A4(3,1)) / (d4 ^ 2);
    Jyz = (C(2,1) - A1(2,1)) * (C(3,1) - A1(3,1)) / (d1 ^ 2) ...
        + (C(2,1) - A2(2,1)) * (C(3,1) - A2(3,1)) / (d2 ^ 2) ...
        + (C(2,1) - A3(2,1)) * (C(3,1) - A3(3,1)) / (d3 ^ 2) ...
        + (C(2,1) - A4(2,1)) * (C(3,1) - A4(3,1)) / (d4 ^ 2);
        
    g = [Jx Jxy Jxz; Jxy Jy Jyz; Jxz Jyz Jz];
    
    % update tag location, using learning rate alpha
    C = C - inv(g) * JqE * alpha;
    
    % check error convergence
    previous_error = overall_error;
    e1  = abs(sqrt((C(1,1) - A1(1,1)) ^ 2 ...
                 + (C(2,1) - A1(2,1)) ^ 2 ...
                 + (C(3,1) - A1(3,1)) ^ 2 ...
                 ) - r1);
    e2  = abs(sqrt((C(1,1) - A2(1,1)) ^ 2 ...
                 + (C(2,1) - A2(2,1)) ^ 2 ...
                 + (C(3,1) - A2(3,1)) ^ 2 ...
                 ) - r2);
    e3  = abs(sqrt((C(1,1) - A3(1,1)) ^ 2 ...
                 + (C(2,1) - A3(2,1)) ^ 2 ...
                 + (C(3,1) - A3(3,1)) ^ 2 ...
                 ) - r3);
    e4  = abs(sqrt((C(1,1) - A4(1,1)) ^ 2 ...
                 + (C(2,1) - A4(2,1)) ^ 2 ...
                 + (C(3,1) - A4(3,1)) ^ 2 ...
                 ) - r4);
                 
    overall_error = e1 + e2 + e3 + e4;
    if overall_error < best_error
        best_error = overall_error;
        best_guess = C;
    end
    
    % terminate on convergence
    if abs(previous_error - overall_error) < 0.0001
        disp(['converged after ', num2str(iter_count), ' iterations']);
        break;
    end
end
disp('lsq guess')
disp(transpose(C1))
disp('lsq error')
disp(lsq_error)
disp('')
disp('nlsq guess')
disp(transpose(C))
disp('nlsq error')
disp(overall_error)
disp('')
disp('best guess')
disp(transpose(best_guess))
disp('best error')
disp(best_error)
disp('')
disp('answer')
disp(transpose(Tag))

